/**
 * Environment file generator for Scanner Map
 * Generates .env files based on user selections
 * 
 * All service URLs are auto-configured based on installation type.
 */

const fs = require('fs-extra');
const path = require('path');

class EnvGenerator {
  constructor(projectRoot) {
    this.projectRoot = projectRoot;
    this.envPath = path.join(projectRoot, '.env');
  }

  /**
   * Generate .env file based on configuration
   */
  async generate(config) {
    const {
      // Installation type
      installationType = 'docker',
      
      // Core settings
      webserverPort = 3001,
      botPort = 3306,
      publicDomain = 'localhost',
      timezone = 'America/New_York',
      
      // Discord
      enableDiscord = false,
      discordToken = '',
      clientId = '',
      
      // Transcription
      transcriptionMode = 'local',
      transcriptionDevice = 'cpu',
      whisperModel = 'small',
      fasterWhisperServerUrl = '',
      
      // AI Provider
      aiProvider = 'openai',
      openaiApiKey = '',
      openaiModel = 'gpt-4o-mini',
      ollamaUrl = '',
      ollamaModel = 'llama3.1:8b',
      
      // Geocoding
      geocodingProvider = 'nominatim',
      googleMapsApiKey = '',
      locationiqApiKey = '',
      geocodingState = 'MD',
      geocodingCountry = 'us',
      geocodingCity = 'Baltimore',
      geocodingTargetCounties = 'Baltimore,Baltimore City,Anne Arundel',
      
      // Storage
      storageMode = 'local',
      
      // Authentication
      enableAuth = false,
      webserverPassword = '',
      sessionDurationDays = 7,
      maxSessionsPerUser = 5,
      
      // Talk Groups
      mappedTalkGroups = '',
      enableMappedTalkGroups = true,
      
      // iCAD
      enableICAD = false,
      icadUrl = '',
      icadProfile = 'default',
      icadApiKey = '',
      
      // TrunkRecorder API key (auto-generated)
      trunkRecorderApiKey = '',
      radioApiKey = '',
      radioSoftware = 'none'
    } = config;

    // Auto-configure URLs based on installation type
    // If ollamaUrl is provided (remote), use it; otherwise auto-configure based on installation type
    const isDocker = installationType === 'docker';
    const finalOllamaUrl = ollamaUrl || (isDocker ? 'http://ollama:11434' : 'http://localhost:11434');
    const finalICADUrl = icadUrl || (isDocker ? 'http://icad-transcribe:9912' : 'http://localhost:9912');

    let envContent = `# ============================================
# Scanner Map Configuration
# ============================================
# Generated by installer on ${new Date().toISOString()}
# Installation Type: ${installationType.toUpperCase()}
#
# All service URLs are auto-configured for ${installationType} installation.
# Edit only if you know what you're doing.
# ============================================

# --- Core Settings ---
WEBSERVER_PORT=${webserverPort}
BOT_PORT=${botPort}
PUBLIC_DOMAIN=${publicDomain}
TIMEZONE=${timezone}

# --- Transcription ---
# Options: local, remote, openai, icad
TRANSCRIPTION_MODE=${transcriptionMode}
`;

    // Add transcription-specific settings
    if (transcriptionMode === 'local') {
      envContent += `TRANSCRIPTION_DEVICE=${transcriptionDevice}
WHISPER_MODEL=${whisperModel}
`;
    } else if (transcriptionMode === 'remote') {
      if (fasterWhisperServerUrl) {
        envContent += `FASTER_WHISPER_SERVER_URL=${fasterWhisperServerUrl}
`;
      }
    } else if (transcriptionMode === 'icad') {
      envContent += `ICAD_URL=${finalICADUrl}
ICAD_PROFILE=${icadProfile}
ICAD_API_KEY=${icadApiKey}
`;
    } else if (transcriptionMode === 'openai') {
      envContent += `OPENAI_TRANSCRIPTION_MODEL=whisper-1
`;
    }

    // AI Provider
    envContent += `
# --- AI Provider ---
# Options: openai, ollama
# Note: API keys are configured via the web UI
AI_PROVIDER=${aiProvider}
`;

    if (aiProvider === 'openai') {
      // OpenAI API key is configured via web UI, not in installer
      envContent += `# OPENAI_API_KEY=  # Configure via web UI
OPENAI_MODEL=${openaiModel}
`;
    } else {
      envContent += `OLLAMA_URL=${finalOllamaUrl}
OLLAMA_MODEL=${ollamaModel}
`;
    }

    // Geocoding
    envContent += `
# --- Geocoding ---
# Provider: nominatim (free), locationiq, google
GEOCODING_PROVIDER=${geocodingProvider}
GEOCODING_STATE=${geocodingState}
GEOCODING_COUNTRY=${geocodingCountry}
GEOCODING_CITY=${geocodingCity}
GEOCODING_TARGET_COUNTIES=${geocodingTargetCounties}
`;

    if (geocodingProvider === 'locationiq') {
      envContent += `LOCATIONIQ_API_KEY=${locationiqApiKey}
`;
    } else if (geocodingProvider === 'google') {
      envContent += `GOOGLE_MAPS_API_KEY=${googleMapsApiKey}
`;
    }

    // Discord
    envContent += `
# --- Discord Bot ---
ENABLE_DISCORD=${enableDiscord}
`;

    if (enableDiscord) {
      envContent += `DISCORD_TOKEN=${discordToken}
CLIENT_ID=${clientId}
`;
    }

    // Authentication
    envContent += `
# --- Authentication ---
ENABLE_AUTH=${enableAuth}
`;

    if (enableAuth) {
      envContent += `WEBSERVER_PASSWORD=${webserverPassword}
SESSION_DURATION_DAYS=${sessionDurationDays}
MAX_SESSIONS_PER_USER=${maxSessionsPerUser}
`;
    }

    // Talk Groups
    envContent += `
# --- Talk Groups ---
ENABLE_MAPPED_TALK_GROUPS=${enableMappedTalkGroups}
MAPPED_TALK_GROUPS=${mappedTalkGroups}

# --- Storage ---
STORAGE_MODE=${storageMode}
`;

    // Add radio software configuration before writing
    if (radioSoftware && radioSoftware !== 'none') {
      envContent += `
# --- Radio Software ---
# Selected radio recording software: ${radioSoftware}
# Options: trunk-recorder, sdrtrunk, rdio-scanner, op25, none
RADIO_SOFTWARE=${radioSoftware}
`;
    }

    // Write .env file
    await fs.ensureDir(path.dirname(this.envPath));
    await fs.writeFile(this.envPath, envContent, 'utf8');
    
    // Use radioApiKey if provided, otherwise fall back to trunkRecorderApiKey for backward compatibility
    const finalRadioApiKey = radioApiKey || trunkRecorderApiKey;

    // Also save the API key to a file for easy reference
    if (finalRadioApiKey) {
      const dataDir = path.join(this.projectRoot, 'data');
      await fs.ensureDir(dataDir);
      
      // Save API key file
      const apiKeyFile = path.join(dataDir, 'apikeys.json');
      const hashedKey = require('crypto').createHash('sha256').update(finalRadioApiKey).digest('hex');
      const apiKeys = [{
        key: hashedKey,
        name: 'Auto-generated',
        createdAt: new Date().toISOString()
      }];
      await fs.writeJson(apiKeyFile, apiKeys, { spaces: 2 });

      // Save plaintext key for reference
      const keyRefFile = path.join(dataDir, 'api-key.txt');
      const softwareName = radioSoftware && radioSoftware !== 'none' 
        ? radioSoftware.charAt(0).toUpperCase() + radioSoftware.slice(1).replace('-', ' ')
        : 'SDRTrunk, TrunkRecorder, or any rdio-scanner compatible software';
      await fs.writeFile(keyRefFile, `Scanner Map API Key
====================
Use this key in ${softwareName}.

API Key: ${finalRadioApiKey}

Endpoint: http://localhost:${botPort}/api/call-upload

Generated: ${new Date().toISOString()}
`, 'utf8');
    }
    
    return this.envPath;
  }

  /**
   * Check if .env already exists
   */
  async exists() {
    return await fs.pathExists(this.envPath);
  }

  /**
   * Backup existing .env file
   */
  async backup() {
    if (await this.exists()) {
      const backupPath = `${this.envPath}.backup.${Date.now()}`;
      await fs.copy(this.envPath, backupPath);
      return backupPath;
    }
    return null;
  }
}

module.exports = EnvGenerator;
