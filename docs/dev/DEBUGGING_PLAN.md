# Debugging Plan: Web UI Failing to Load

## 1. Problem Restatement

**Observable Symptoms:**
- Installer completes successfully
- Web UI fails to load when accessing `http://localhost:3001` (or configured port)
- No visible errors in some cases, or silent failure
- Application may start but webserver process exits immediately
- In Docker: Container may restart continuously
- In Local: Process may exit or hang without serving the web UI

**Key Indicators:**
- Browser shows connection refused, timeout, or blank page
- No webserver process listening on configured port
- Logs show webserver exit or error messages before startup completes

## 2. Environment & Assumptions

**Runtime Environment:**
- **Operating Systems:** Windows 10/11, Linux (various distros), macOS
- **Installation Types:** Docker (docker-compose), Local (Node.js direct)
- **Node.js Version:** 18+ (assumed, should verify)
- **Python Version:** 3.10+ (for local transcription mode)

**Configuration Sources:**
- `.env` file generated by installer (`scripts/installer/env-generator.js`)
- Environment variables passed to Docker containers
- Environment variables in shell for local installs

**Architecture:**
- **Docker:** Container runs `node bot.js` as CMD, bot.js spawns `webserver.js` as child process
- **Local:** Same pattern - `node bot.js` spawns `webserver.js` as child process
- Both share same `.env` file

**Key Configuration Files:**
- `.env` - Generated by installer, required for both bot.js and webserver.js
- `docker-compose.yml` - Generated by installer, mounts `.env` file
- `bot.js` - Main entrypoint, starts webserver as child process
- `webserver.js` - Express server, exits early if validation fails

## 3. Known-Good vs Known-Bad Behavior

### Known-Good Behavior:
1. **Installation completes** - `.env` file created with all required variables
2. **bot.js starts** - Initializes database, loads configuration
3. **webserver.js starts** - Express server begins listening on `WEBSERVER_PORT`
4. **Web UI accessible** - Browser can access `http://PUBLIC_DOMAIN:WEBSERVER_PORT`
5. **Health check passes** - `/api/test` endpoint returns 200 OK

### Known-Bad Behavior (Failure Scenarios):

**Scenario A: Missing Required Environment Variables**
- `webserver.js` validates `WEBSERVER_PORT` and `PUBLIC_DOMAIN` at startup (lines 52-58)
- If missing, exits immediately with `process.exit(1)`
- No webserver process remains running
- **Symptom:** Silent exit, no error visible in bot.js logs (child process exit not caught properly)

**Scenario B: Geocoding Service Not Configured**
- `webserver.js` requires geocoding provider (lines 60-69)
- Must have: `GEOCODING_PROVIDER=nominatim` OR `GOOGLE_MAPS_API_KEY` OR `LOCATIONIQ_API_KEY`
- If none present, exits with `process.exit(1)`
- **Symptom:** "ERROR: Geocoding service not configured" message, then exit

**Scenario C: bot.js Doesn't Start Webserver (Conditional Logic)**
- `bot.js` only starts webserver if BOTH conditions met (lines 1318-1322):
  1. `WEBSERVER_PORT` is truthy
  2. `hasGeocoding` evaluates to true
- If either fails, logs warning but doesn't start webserver
- **Symptom:** "Webserver not started: WEBSERVER_PORT or geocoding service not configured" warning

**Scenario D: Port Already in Use**
- If port is occupied, `server.listen()` fails
- Error may not be properly caught/logged
- **Symptom:** EADDRINUSE error, webserver fails to bind

**Scenario E: Docker Environment Variable Issues**
- `.env` file mounted but variables not accessible in container
- Docker Compose may not be reading `.env` properly
- **Symptom:** Container starts but webserver exits, logs show missing variables

**Scenario F: Child Process Exit Not Detected**
- `bot.js` spawns webserver but doesn't properly handle early exit
- Uses `setTimeout` to assume success after 2 seconds (line 1261)
- If webserver exits in < 2 seconds, bot.js thinks it succeeded
- **Symptom:** bot.js logs success, but webserver already exited

## 4. Likely Failure Domains (Ranked)

### ðŸ”´ CRITICAL (Most Likely) - Rank 1
**Missing or Invalid Environment Variables in .env File**
- **Reasoning:** Installer may not set `PUBLIC_DOMAIN` correctly, or geocoding provider may be missing
- **Evidence:** `webserver.js` exits immediately if `WEBSERVER_PORT` or `PUBLIC_DOMAIN` missing (lines 52-58)
- **Impact:** Complete failure - webserver never starts
- **Files:** `scripts/installer/env-generator.js`, `webserver.js` lines 22-69

### ðŸ”´ CRITICAL - Rank 2
**Geocoding Provider Not Configured**
- **Reasoning:** Installer defaults to `nominatim` but validation logic may be case-sensitive or missing
- **Evidence:** `webserver.js` requires explicit geocoding config (lines 60-69), `bot.js` checks `hasGeocoding` (lines 1313-1316)
- **Impact:** Complete failure - webserver exits or never starts
- **Files:** `scripts/installer/env-generator.js` line 153, `webserver.js` lines 60-69, `bot.js` lines 1313-1316

### ðŸŸ¡ HIGH - Rank 3
**Docker Environment Variable Propagation**
- **Reasoning:** `.env` file mounted but variables may not be available to child processes or Docker environment
- **Evidence:** Docker Compose mounts `.env` but doesn't explicitly pass all variables (docker-compose.yml lines 44, 47-48)
- **Impact:** Variables exist in file but not in process.env
- **Files:** `docker-compose.yml`, `Dockerfile`, `webserver.js` (uses `require('dotenv').config()`)

### ðŸŸ¡ HIGH - Rank 4
**Child Process Exit Handling in bot.js**
- **Reasoning:** `startWebserver()` uses setTimeout instead of checking if process actually started (lines 1246-1265)
- **Evidence:** No error handling for early exit, assumes success after 2 seconds
- **Impact:** bot.js thinks webserver started, but it already exited
- **Files:** `bot.js` lines 1246-1265

### ðŸŸ¡ MEDIUM - Rank 5
**Port Conflicts (Already in Use)**
- **Reasoning:** Port 3001 may be occupied by another service
- **Evidence:** `server.listen()` will fail with EADDRINUSE if port occupied
- **Impact:** Webserver fails to bind, exits
- **Files:** `webserver.js` line 2794

### ðŸŸ¡ MEDIUM - Rank 6
**Database Connection Issues**
- **Reasoning:** SQLite database may not be accessible or locked
- **Evidence:** webserver.js opens database early in execution
- **Impact:** Webserver may fail during initialization
- **Files:** `webserver.js` (database initialization code)

### ðŸŸ¢ LOW - Rank 7
**File Path Issues (Logs Directory)**
- **Reasoning:** Directory creation should work, but permissions may fail
- **Evidence:** `fs.ensureDirSync(logsDir)` at line 19
- **Impact:** May cause startup failure if directory can't be created
- **Files:** `webserver.js` line 18-19

## 5. Instrumentation Needed

### Logs to Add/Capture:
1. **Environment Variable Validation Logging:**
   - Log all required env vars at webserver startup (before validation)
   - Log which variables are missing
   - Log geocoding provider detection results

2. **Child Process Monitoring:**
   - Log webserver process PID in bot.js
   - Log webserver exit code and signal
   - Add error handler for child process stderr
   - Verify webserver actually started (check if port is listening)

3. **Startup Sequence Logging:**
   - Log each validation step in webserver.js
   - Log server.listen() success/failure
   - Log when server is actually ready to accept connections

4. **Docker-Specific Logging:**
   - Log environment variables available in container
   - Log .env file contents (masked)
   - Log dotenv.config() results

### Assertions/Probes to Add:
1. **Pre-startup Health Checks:**
   - Verify port is available before binding
   - Verify database file is accessible
   - Verify all required directories exist

2. **Post-startup Verification:**
   - HTTP request to `/api/test` after assumed startup
   - Verify process is actually listening on port
   - Check child process is still alive

3. **Environment Validation:**
   - Assert all required variables present
   - Assert geocoding provider is valid
   - Assert port is valid number

### Flags to Add:
1. **Debug Mode Flag:**
   - `DEBUG_WEBSERVER=true` - Enable verbose webserver logging
   - `DEBUG_ENV=true` - Log all environment variables (masked)

2. **Startup Verification Flag:**
   - Verify webserver started before bot.js continues
   - Fail fast if webserver doesn't start

## 6. Step-by-Step Isolation Plan

### Phase 1: Verify Environment Configuration (Smallest Test First)
**Goal:** Confirm .env file contains all required variables

**Steps:**
1. **Test 1.1:** Check .env file exists and is readable
   - Command: `cat .env` (Linux/Mac) or `type .env` (Windows)
   - Expected: File exists with WEBSERVER_PORT and PUBLIC_DOMAIN
   
2. **Test 1.2:** Verify required variables in .env
   - Command: `grep -E "^(WEBSERVER_PORT|PUBLIC_DOMAIN|GEOCODING_PROVIDER)=" .env`
   - Expected: All three present with non-empty values

3. **Test 1.3:** Verify geocoding configuration
   - Command: `grep -E "^(GEOCODING_PROVIDER|GOOGLE_MAPS_API_KEY|LOCATIONIQ_API_KEY)=" .env`
   - Expected: GEOCODING_PROVIDER=nominatim OR one API key present

**Success Criteria:** All required variables present with valid values

### Phase 2: Test Webserver Direct Startup (Isolate from bot.js)
**Goal:** Determine if webserver.js can start independently

**Steps:**
1. **Test 2.1:** Start webserver.js directly (Local)
   - Command: `node webserver.js`
   - Expected: Server starts, logs show "Web server running on port X"
   - If fails: Capture exact error message

2. **Test 2.2:** Verify webserver responds (Local)
   - Command: `curl http://localhost:3001/api/test` (or configured port)
   - Expected: 200 OK response

3. **Test 2.3:** Check if port is available
   - Command: `netstat -ano | findstr :3001` (Windows) or `lsof -i :3001` (Linux/Mac)
   - Expected: Port is free or shows our process

**Success Criteria:** Webserver starts independently and responds to requests

### Phase 3: Test bot.js Webserver Startup Logic
**Goal:** Verify bot.js correctly starts and monitors webserver child process

**Steps:**
1. **Test 3.1:** Start bot.js with webserver spawning
   - Command: `node bot.js`
   - Expected: Logs show "Starting webserver..." then "Webserver started on port X"
   - Monitor: Check if webserver process actually exists

2. **Test 3.2:** Verify child process handling
   - Check: Does bot.js detect if webserver exits early?
   - Check: Does bot.js log webserver errors?
   - Expected: Proper error handling if webserver fails

3. **Test 3.3:** Test geocoding detection logic
   - Modify: Temporarily remove geocoding from .env
   - Expected: bot.js logs warning, doesn't start webserver
   - Restore: Add geocoding back

**Success Criteria:** bot.js properly starts and monitors webserver, detects failures

### Phase 4: Test Docker Environment
**Goal:** Verify Docker-specific environment variable issues

**Steps:**
1. **Test 4.1:** Verify .env file is mounted in container
   - Command: `docker exec scanner-map cat /app/.env | grep -E "^(WEBSERVER_PORT|PUBLIC_DOMAIN|GEOCODING_PROVIDER)="`
   - Expected: Variables present in container

2. **Test 4.2:** Verify environment variables in container process
   - Command: `docker exec scanner-map node -e "require('dotenv').config(); console.log(process.env.WEBSERVER_PORT, process.env.PUBLIC_DOMAIN, process.env.GEOCODING_PROVIDER)"`
   - Expected: Variables accessible to Node.js process

3. **Test 4.3:** Check container logs for webserver startup
   - Command: `docker-compose logs scanner-map | grep -i webserver`
   - Expected: Webserver startup messages, no exit errors

4. **Test 4.4:** Test direct webserver start in container
   - Command: `docker exec scanner-map node webserver.js`
   - Expected: Server starts or shows specific error

**Success Criteria:** Environment variables properly accessible in Docker, webserver can start

### Phase 5: Cross-Platform Testing
**Goal:** Verify behavior across different operating systems

**Steps:**
1. **Test 5.1:** Windows-specific path handling
   - Check: Directory creation with Windows paths
   - Check: .env file reading on Windows

2. **Test 5.2:** Linux-specific permissions
   - Check: Directory permissions for logs/data
   - Check: Process spawning permissions

3. **Test 5.3:** macOS-specific issues
   - Check: Port binding permissions
   - Check: File system case sensitivity

**Success Criteria:** Works consistently across all platforms

### Phase 6: Integration Testing
**Goal:** Verify full installation â†’ startup â†’ web UI access flow

**Steps:**
1. **Test 6.1:** Fresh installation (Docker)
   - Run installer
   - Start docker-compose
   - Verify web UI accessible
   - Check logs for errors

2. **Test 6.2:** Fresh installation (Local)
   - Run installer
   - Start `node bot.js`
   - Verify web UI accessible
   - Check logs for errors

3. **Test 6.3:** Edge cases
   - Installation with minimal config (quick setup)
   - Installation with advanced config
   - Installation with different geocoding providers

**Success Criteria:** Full flow works end-to-end for all installation types

## 7. Success Criteria

### Immediate Fix Success (What Proves the Issue is Fixed):
1. âœ… **Webserver starts successfully** - Logs show "Web server running on port X"
2. âœ… **Web UI is accessible** - Browser can load `http://localhost:3001` (or configured port)
3. âœ… **API endpoints respond** - `/api/test` returns 200 OK
4. âœ… **No early exits** - Webserver process remains running (not exiting immediately)
5. âœ… **Proper error messages** - If failure occurs, clear error message explains why

### Comprehensive Success (All Scenarios):
1. âœ… **Docker installation works** - Container starts, webserver runs, web UI accessible
2. âœ… **Local installation works** - Process starts, webserver runs, web UI accessible
3. âœ… **Windows works** - No path or permission issues
4. âœ… **Linux works** - No permission or port binding issues
5. âœ… **macOS works** - No case sensitivity or permission issues
6. âœ… **Quick setup works** - Minimal configuration succeeds
7. âœ… **Advanced setup works** - Full configuration succeeds
8. âœ… **All geocoding providers work** - nominatim, locationiq, google all start webserver

### Verification Commands:
```bash
# Docker
docker-compose up -d
sleep 5
curl http://localhost:3001/api/test
docker-compose logs scanner-map | grep -i "web server running"

# Local
node bot.js &
sleep 5
curl http://localhost:3001/api/test
ps aux | grep webserver.js
```

## 8. Risks of Premature Fixes

### Risk 1: Masking Root Cause
**Risk:** Adding workarounds (like default values) without fixing underlying configuration issue
**Impact:** Problem appears fixed but breaks in other scenarios
**Mitigation:** Always fix root cause (installer/config generation) not symptoms (validation)

### Risk 2: Breaking Existing Working Installations
**Risk:** Changing validation logic may allow invalid configurations to start
**Impact:** Users with working configs may break
**Mitigation:** Ensure changes are backward compatible, add migration logic if needed

### Risk 3: Platform-Specific Assumptions
**Risk:** Fixing for one OS may break others (e.g., Windows path handling)
**Impact:** Fixes one platform, breaks others
**Mitigation:** Test on all target platforms, use cross-platform libraries

### Risk 4: Silent Failures Become Silent Successes
**Risk:** Removing validation checks to "fix" startup issues
**Impact:** Application starts but doesn't work correctly (missing required config)
**Mitigation:** Keep validation, improve error messages and recovery

### Risk 5: Docker vs Local Divergence
**Risk:** Fixing Docker may break local, or vice versa
**Impact:** One installation type works, other breaks
**Mitigation:** Test both paths, ensure shared code paths work for both

### Risk 6: Timing Issues (Race Conditions)
**Risk:** Fixing child process startup without addressing timing issues
**Impact:** Works in testing but fails under load or slow systems
**Mitigation:** Use proper async/await patterns, verify actual startup not timeouts

### Risk 7: Missing Edge Cases
**Risk:** Fixing common case but missing edge cases (e.g., empty strings vs undefined)
**Impact:** Most users work, some edge cases still fail
**Mitigation:** Comprehensive test coverage, handle all falsy value cases

### Risk 8: Configuration Migration Issues
**Risk:** Changing .env format breaks existing user configs
**Impact:** Existing installations break after update
**Mitigation:** Provide migration script or backward compatibility layer

---

## Next Steps

After approval of this plan, proceed with:
1. Adding instrumentation (logging, assertions)
2. Running isolation tests (Phases 1-6)
3. Identifying root cause based on test results
4. Implementing fix with comprehensive testing
5. Verifying success criteria met
6. Cross-platform validation

